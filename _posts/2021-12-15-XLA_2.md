---
layout: post
author: dinhhuyhoang
title: Bài 10 - Xử lí ảnh cơ bản (2/3)
---

## 1. Image Segmentation

Image Segmentation (phân khúc ảnh) là một bài toán lớn và xuất hiện khá lâu đời trong thị giác máy tính. Hiểu đơn giản thì input của bài toán là 1 bức ảnh hoặc frame của video và output sẽ là nhãn của từng giá trị pixel và mong sao các object có cùng class sẽ có giá trị pixel giống nhau. Ví dụ minh họa:

<img src="/assets/images/bai10/anh1.jpg" class="normalpic"/>

Tại thời điểm viết, các bài toán Image Segmentation được xử lí rất tốt bởi các mô hình Deep Learning tuy nhiên trước khi Deep Learning phát triển mạnh như ngày nay các thuật toán cổ điển làm việc như thế nào cùng tìm hiểu bên dưới, ngoài ra đôi khi với 1 số tác vụ đơn giản sẽ không cần ôm một mô hình Deep Learning hàng triệu tham số để tính toán là không cần thiết.

### 1.1. Thresholding algorithm

Phân khúc ảnh dựa trên ngưỡng (threshold) là một thuật toán khá đơn giản, bức ảnh ban đầu sẽ chuyển sang không gian grayscale sau đó sẽ xác định màu của mỗi pixel thuộc nhãn 0 (đen) hoặc 255 (trắng) tức ảnh đầu ra sẽ là một binary image. Để có thể làm hình ảnh grayscale thành binary ta sẽ xét một ngưỡng nguyên dương $T$ nằm trong đoạn (0, 255), với những pixel nhỏ hơn ngưỡng $T$ thì sẽ được xét là 0, ngược lại xét là 255. Với kết quả đầu ra của thuật toán threshold ta có thể tìm được các vùng có thể có đối tượng được quan tâm (ROI - Regions of interest) tách ra khỏi phần background của ảnh. 

#### 1.1.1 Simple thresholding

Simple thresholding sẽ cần ta xác định ngưỡng $T$, với những giá trị pixels nhỏ hơn $T$ ta sẽ xét bằng 0, ngược lại xét bằng 255.

$$\begin{equation}
  B(x,y)=\begin{cases}
    0, & \text{if G(x,y) \leq T}\\
    255, & \text{otherwise}
  \end{cases}
\end{equation}
$$

Việc thực hành với OpenCV khá đơn giản, thao tác với Python:

```python
import numpy as np
import cv2
import matplotlib.pyplot as plt

gray_img = cv2.imread('coin.jpg',0)

T = 125 # threshold value

_, thresh_img = cv2.threshold(gray_img, T, 255, cv2.THRESH_BINARY)
_, thresh_img_inv = cv2.threshold(gray_img, T, 255, cv2.THRESH_BINARY_INV)
X = cv2.bitwise_and(gray_img, thresh_img_inv)

plt.figure(figsize=(16, 4))
plt.subplot(151),plt.imshow(gray_img,cmap='gray'),plt.title('Origin'),plt.axis(False)
plt.subplot(152),plt.imshow(thresh_img,cmap='gray'),plt.title('THRESH BINARY'),plt.axis(False)
plt.subplot(153),plt.imshow(thresh_img_inv,cmap='gray'),plt.title('THRESH BINARY INV'),plt.axis(False)
plt.subplot(154),plt.imshow(X,cmap='gray'),plt.title('Bitwise And'),plt.axis(False)
plt.show()
```

**Kết quả:**

<img src="/assets/images/bai10/anh2.png" class="large"/>

**Nhận xét:**

- OpenCV cung cấp hàm `cv2.threshold` gồm 4 đối số: ảnh grayscale, ngưỡng threshold $T$, giá trị nếu pixel lớn hơn $T$ (ở ví dụ trên thì với bất kì giá trị pixel nào lớn hơn 125 sẽ gán bằng 255, ngược lại gán = 0), `cv2.THRESH_BINARY` sẽ coi giá trị khi lớn là 0, nhỏ hơn là 255 và `cv2.THRESH_BINARY_INV` thì ngược lại (ở phần này bạn có thể nhìn hình kết quả và code để suy ra một cách đơn giản).

- Để visualize rõ ràng kết quả, mình đã sử dụng phép toán `cv2.bitwise_and` để kết hợp ảnh gốc với ảnh nhị phân. Nếu bạn chưa biết cách phép tính này hoạt động như thế nào bạn có thể xem lại [tại đây](https://hnhoangdz.github.io/2021/11/29/XLA_1.html#52-bitwise).

- Kết quả này đã giúp chúng ta phân biệt rõ được các đồng coin và background của chúng, tuy nhiên một hạn chế lớn của phương pháp này là ta đang phải chọn ngưỡng $T$ thủ công, tức sẽ phải tuning nhiều lần (bạn có thể thử thay đổi các giá trị $T$ và xem xét các kết quả khác nhau).

#### 1.1.2. Ostu thresholding

Một trong những hạn chế của phương pháp Simple thresholding là phải chọn ngưỡng $T$, việc chọn ngưỡng $T$ một cách thủ công có thể làm việc vẫn tốt trong trường hợp điều kiện ánh sáng trong ảnh khá rõ nét. Tuy nhiên trong thực tế, các hình ảnh thu thập sẽ không có điều kiện ánh sáng tốt và dễ dàng phân biệt, vì vậy thuật Ostu ra đời nhằm tìm ngưỡng $T$ một cách tối ưu nhất.

Ý tưởng của thuật toán Ostu tập trung vào việc khai thác những thông tin hữu ích của Histogram trong ảnh. Ý nghĩa của Histogram nhằm giúp ta có thể chọn ngưỡng $T$ một cách tốt nhất để phân biệt giữa Foreground và Background ([Histogram là gì?](https://hnhoangdz.github.io/2021/11/29/XLA_1.html#54-histogram)). Để hiểu rõ cách hoạt động của phương pháp này hãy xem ví dụ sau:

<img src="/assets/images/bai10/anh2.jpg" class="normalpic"/>

Với bức ảnh 6 x 6 bên tay phải ta có một biểu đồ Histogram tương ứng. Giả sử ta chọn ngưỡng giá trị 3 làm ngưỡng để phân chia giữa Background và Foreground chia thành 2 nhãn (B - Background, F - Foreground), sau đó ta sẽ tính toán các tham số cho 2 nhãn này như sau:

<img src="/assets/images/bai10/anh3.jpg" class="normalpic"/>

#### 1.1.3. Adaptive thresholding

 hơn nữa khi dải màu trong ảnh được trải rộng thì một ngưỡng $T$ sẽ có sai số khá nhiều. Vì vậy thuật toán adaptive thresholding sẽ giải quyết vấn đề này khá tốt bằng cách tìm những vùng lân cận liền kề trong ảnh giá trị ngưỡng $T$ tối ưu nhất có thể. Vì vậy với dải màu trong ảnh được trải rộng thì sẽ có nhiều giá trị ngưỡng $T$ khác nhau trong mỗi vùng ảnh. Đầu tiên hãy xem cách thao tác với Python và kết quả:


